#include <stdio.h>
#include <math.h>
#include <webots/robot.h>
#include <webots/motor.h>
#include <webots/distance_sensor.h>
#include <webots/led.h>
#include <webots/camera.h>
#include <webots/supervisor.h>
#define TIME_STEP 8

/*---------------------Định nghĩa---------------------*/

// Signal
#define DEFAULT 0
#define PREPARE_LEFT 1
#define PREPARE_RIGHT 2
#define TURN_LEFT 3
#define TURN_RIGHT 4
#define LEFT_TRANSITION 5
#define RIGHT_TRANSITION 6
#define SWITCH_LEFT 7
#define SWITCH_RIGHT 8
#define PREPARE_CIRCLE 9
#define CIRCLE 10
#define TURN_RIGHT_CIRCLE 11
#define MAX_SPEED 10

// Sensors
#define NB_GROUND_SENS 8

// LEDs
#define NB_LEDS 5

/*--------------Khởi tạo thông tin robot--------------*/

// KHÔNG CHỈNH SỬA TIME_STEP !!!
// Khai báo biến cho các sensors
unsigned short threshold[NB_GROUND_SENS] = {300, 300, 300, 300, 300, 300, 300, 300};
unsigned int filted[8] = {0, 0, 0, 0, 0, 0, 0, 0};
const float weights[8] = {-3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5};
float currWeight = 0;
int state = DEFAULT;
unsigned char sensors[6] = {0, 0, 0, 0, 0, 0};
bool stop = false;
double stopTime = -1.0;
double prevTime = -1.0;
double currTime = -1.0;
int activeLeft = 0;
int activeRight = 0;
int activeCenter = 0;
int activeTotal = 0;

bool noise = false;

// Velocities
float leftRatio = 0.0;
float rightRatio = 0.0;
const float base = 5.0;
float OPturnRatio = -1.5;
float turnRatio = 1.5;

// Timing
float ninetydegturntiming = 0.4;

// Sensors
WbDeviceTag gs[NB_GROUND_SENS];

// LEDs
WbDeviceTag led[NB_LEDS];

// Motors
WbDeviceTag left_motor, right_motor;

/*----------------Phần code code set up---------------*/

/* Hàm đọc giá trị sensors
KHÔNG ĐƯỢC THIẾU!!!     */
void ReadSensors()
{
    unsigned short gs_value[NB_GROUND_SENS] = {0, 0, 0, 0, 0, 0, 0, 0};
    for (int i = 0; i < NB_GROUND_SENS; i++)
    {
        gs_value[i] = wb_distance_sensor_get_value(gs[i]);
        // So sánh giá trị gs_value với threshold -> chuyển đổi sang nhị phân
        if (gs_value[i] < threshold[i])
            filted[i] = 1;
        else
            filted[i] = 0;
    };
};

// Lưu trữ 6 bộ giá trị sensors gần nhất
void getSensors()
{
    for (int i = 0; i < 5; i++)
        sensors[i] = sensors[i + 1];
    for (int i = 0; i < NB_GROUND_SENS; i++)
    {
        sensors[5] <<= 1;
        sensors[5] |= (filted[i] & 1);
    };
}

void getActive()
{
    for (int i = 0; i < 8; i++)
        if (filted[i] == 1)
            activeTotal++;
    for (int i = 0; i < 4; i++)
        if (filted[i] == 1)
            activeLeft++;
    for (int i = 7; i > 3; i--)
        if (filted[i] == 1)
            activeRight++;
    for (int i = 3; i < 5; i++)
        if (filted[i] == 1)
            activeCenter++;
}

double getTime()
{
    return wb_robot_get_time();
}

// Kiểm tra điều kiện dừng
void stopHandler()
{
    stop = true;
    for (int i = 0; i < 6; i++)
    {
        if (sensors[i] != 255)
        {
            stop = false;
            return;
        }
    }
    if (stopTime == -1.0)
    {
        stopTime = getTime();
        printf("\n\t\tStopping at %f seconds", stopTime);
    }
}

// Kiểm tra tín hiệu nhiễu
void noiseHandler()
{
    if (
        ((sensors[3] == 8) || (sensors[3] == 12) || (sensors[3] == 16) || (sensors[3] == 24) || (sensors[3] == 48)) &&
        ((sensors[4] != 8) && (sensors[4] != 12) && (sensors[4] != 16) && (sensors[4] != 24) && (sensors[4] != 48)) &&
        ((sensors[5] == 8) || (sensors[5] == 12) || (sensors[5] == 16) || (sensors[5] == 24) || (sensors[5] == 48)))
    {
        printf("\n\t\tNoise detected, ignoring signal!");
        noise = true;
    }
}

int circleHandler()
{
    for (int i = 0; i < 6; i++)
    {
        if ((sensors[i] < 8) || (sensors[i] > 24))
            return 1;
    }
    return 0;
}

// Xử lý tín hiệu sensors, tìm trọng số

float getWeightCircle()
{
    if ((activeRight >= 3) && (filted[7] == 1))
    {
        state = TURN_RIGHT;
        return 0;
    }

    if (activeCenter == 2)
        return 0;
    for (int i = 0; i < 4; i++)
    {
        if (filted[i] == 1)
            return weights[i];
        else if (filted[7 - i] == 1)
            return weights[7 - i];
    }
    return 0;
}

float getWeight()
{
    if (sensors[5] == 255)
    {
        printf("\n\t\tPrepare circle");
        state = PREPARE_CIRCLE;
        prevTime = getTime();
        return 0;
    }

    if ((activeLeft >= 3) && (filted[0] == 1))
    {
        state = PREPARE_LEFT;
        return 0;
    }

    if ((activeRight >= 3) && (filted[7] == 1))
    {
        state = PREPARE_RIGHT;
        return 0;
    }

    if (activeCenter == 2)
        return 0;
    for (int i = 0; i < 4; i++)
    {
        if (filted[i] == 1)
            return weights[i];
        else if (filted[7 - i] == 1)
            return weights[7 - i];
    }
    return 0;
}

// Hàm điều khiển robot
void Drive()
{
    switch (state)
    {
    case PREPARE_LEFT:
        noiseHandler();
        leftRatio = base;
        rightRatio = base;
        if (activeTotal == 0)
            state = TURN_LEFT;
        else if ((activeCenter >= 1) && (activeTotal <= 2))
            state = LEFT_TRANSITION;
        break;

    case PREPARE_RIGHT:
        noiseHandler();
        leftRatio = base;
        rightRatio = base;
        if (activeTotal == 0)
            state = TURN_RIGHT;
        else if ((activeCenter >= 1) && (activeTotal <= 2))
            state = RIGHT_TRANSITION;
        break;

    case LEFT_TRANSITION:
        noiseHandler();
        leftRatio = base;
        rightRatio = base;
        if (activeTotal >= 5)
            state = TURN_LEFT;
        else if (activeTotal == 0)
        {
            state = SWITCH_LEFT;
            prevTime = getTime();
        }
        break;

    case RIGHT_TRANSITION:
        noiseHandler();
        leftRatio = base;
        rightRatio = base;
        if (activeTotal >= 5)
            state = TURN_RIGHT;
        else if (activeTotal == 0)
        {
            state = SWITCH_RIGHT;
            prevTime = getTime();
        }
        break;

    case SWITCH_LEFT:
        currTime = getTime();
        rightRatio = turnRatio;
        leftRatio = OPturnRatio;
        if (currTime - prevTime >= ninetydegturntiming)
        {
            rightRatio = base;
            leftRatio = base;
            if (activeTotal != 0) state = TURN_RIGHT;
        }
        break;

    case SWITCH_RIGHT:
        currTime = getTime();
        rightRatio = OPturnRatio;
        leftRatio = turnRatio;
        if (currTime - prevTime >= ninetydegturntiming)
        {
            rightRatio = base;
            leftRatio = base;
            if (activeTotal != 0) state = TURN_LEFT;
        }
        break;

    case TURN_LEFT:
        leftRatio = OPturnRatio;
        rightRatio = turnRatio;
        if ((sensors[4] == 128) && (activeLeft >= 2))
            state = DEFAULT;
        break;

    case TURN_RIGHT:
        leftRatio = turnRatio;
        rightRatio = OPturnRatio;
        if ((sensors[4] == 1) && (activeRight >= 2))
            state = DEFAULT;
        break;

    case DEFAULT:
        noiseHandler();
        currWeight = getWeight();

        if (currWeight > 0)
        {
            leftRatio = base + 1.0;
            rightRatio = base - currWeight;
        }
        else if (currWeight < 0)
        {
            leftRatio = base + currWeight;
            rightRatio = base + 1.0;
        }
        else
        {
            leftRatio = base;
            rightRatio = base;
        }
        break;
    case PREPARE_CIRCLE:
        noiseHandler();
        leftRatio = base;
        rightRatio = base;
        currTime = getTime();
        if (currTime - prevTime >= 0.1)
        {
            printf("\n\t\tDELAY IS OVER");
            if ((activeRight >= 3) && (filted[7] == 1))
            {
                state = TURN_RIGHT_CIRCLE;
            }
        }
        break;
    case TURN_RIGHT_CIRCLE:
        leftRatio = turnRatio;
        rightRatio = OPturnRatio;
        if ((activeRight >= 2) && (activeTotal == activeRight))
            state = CIRCLE;
        break;

    case CIRCLE:
        noiseHandler();
        currWeight = getWeightCircle();

        if (currWeight > 0)
        {
            leftRatio = base + 1.0;
            rightRatio = base - currWeight;
        }
        else if (currWeight < 0)
        {
            leftRatio = base + currWeight;
            rightRatio = base + 1.0;
        }
        else
        {
            leftRatio = base;
            rightRatio = base;
        }
    }
}

/*---------------------Main loop---------------------*/

int main()
{
    /*------------------Khởi động robot------------------*/

    /* Khởi động robot
    KHÔNG ĐƯỢC BỎ!!! */
    wb_robot_init();

    // Khởi động camera
    WbDeviceTag camera = wb_robot_get_device("camera");
    wb_camera_enable(camera, 64);

    // Khởi động sensors
    char name[20];
    for (int i = 0; i < NB_GROUND_SENS; i++)
    {
        sprintf(name, "gs%d", i);
        gs[i] = wb_robot_get_device(name); /* ground sensors */
        wb_distance_sensor_enable(gs[i], TIME_STEP);
    };

    // Khởi động LEDs
    for (int i = 0; i < NB_LEDS; i++)
    {
        sprintf(name, "led%d", i);
        led[i] = wb_robot_get_device(name);
        wb_led_set(led[i], 1);
    };

    // Khởi động Motors
    left_motor = wb_robot_get_device("left wheel motor");
    right_motor = wb_robot_get_device("right wheel motor");
    wb_motor_set_position(left_motor, INFINITY);
    wb_motor_set_position(right_motor, INFINITY);
    wb_motor_set_velocity(left_motor, 0.0);
    wb_motor_set_velocity(right_motor, 0.0);

    // Chương trình sẽ được lặp lại vô tận trong hàm while
    while (wb_robot_step(TIME_STEP) != -1)
    {
        ReadSensors();

        getSensors();

        getActive();
        // In giá trị của cảm biến ra màn hình
        printf("\n\t\tPosition: 0b");
        for (int i = 0; i < 8; i++)
        {
            printf("%u", filted[i]);
        };

        // In giá trị trạng thái của xe
        printf("\tCurrent state: %d", state);

        /*----------Điều khiển xe----------*/
        Drive();
        activeLeft = 0;
        activeRight = 0;
        activeCenter = 0;
        activeTotal = 0;

        // Nếu có tín hiệu nhiễu, bỏ qua tín hiệu và trở về trạng thái mặc định
        if (noise)
        {
            leftRatio = base;
            rightRatio = base;
            state = DEFAULT;
            noise = false;
        }
        // Điều chỉnh tốc độ động cơ
        printf("\tL/R: %f/%f", leftRatio, rightRatio);
        wb_motor_set_velocity(left_motor, leftRatio * MAX_SPEED);
        wb_motor_set_velocity(right_motor, rightRatio * MAX_SPEED);

        // Kiểm tra điều kiện dừng và dừng robot nếu thoả mãn điều kiện
        stopHandler();
        if (stop && (stopTime != -1.0))
        {
            printf("\n\t\tSTOPPING!");
            wb_motor_set_velocity(left_motor, base);
            wb_motor_set_velocity(right_motor, base);
            if ((getTime() - stopTime) > 1.5)
            {
                printf("\n\t\tStopped at %f seconds", wb_robot_get_time());
                wb_motor_set_velocity(left_motor, 0);
                wb_motor_set_velocity(right_motor, 0);
                break;
            }
        }
    };
    wb_robot_cleanup();
    return 0;
};
